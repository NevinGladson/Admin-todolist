{"ast":null,"code":"import{Children,cloneElement,isValidElement}from'react';/**\n * Given `this.props.children`, return an object mapping key to child.\n *\n * @param {*} children `this.props.children`\n * @return {object} Mapping of key to child\n */export function getChildMapping(children,mapFn){var mapper=function mapper(child){return mapFn&&/*#__PURE__*/isValidElement(child)?mapFn(child):child;};var result=Object.create(null);if(children)Children.map(children,function(c){return c;}).forEach(function(child){// run the map function here instead so that the key is the computed one\nresult[child.key]=mapper(child);});return result;}/**\n * When you're adding or removing children some may be added or removed in the\n * same render pass. We want to show *both* since we want to simultaneously\n * animate elements in and out. This function takes a previous set of keys\n * and a new set of keys and merges them with its best guess of the correct\n * ordering. In the future we may expose some of the utilities in\n * ReactMultiChild to make this easy, but for now React itself does not\n * directly have this concept of the union of prevChildren and nextChildren\n * so we implement it here.\n *\n * @param {object} prev prev children as returned from\n * `ReactTransitionChildMapping.getChildMapping()`.\n * @param {object} next next children as returned from\n * `ReactTransitionChildMapping.getChildMapping()`.\n * @return {object} a key set that contains all keys in `prev` and all keys\n * in `next` in a reasonable order.\n */export function mergeChildMappings(prev,next){prev=prev||{};next=next||{};function getValueForKey(key){return key in next?next[key]:prev[key];}// For each key of `next`, the list of keys to insert before that key in\n// the combined list\nvar nextKeysPending=Object.create(null);var pendingKeys=[];for(var prevKey in prev){if(prevKey in next){if(pendingKeys.length){nextKeysPending[prevKey]=pendingKeys;pendingKeys=[];}}else{pendingKeys.push(prevKey);}}var i;var childMapping={};for(var nextKey in next){if(nextKeysPending[nextKey]){for(i=0;i<nextKeysPending[nextKey].length;i++){var pendingNextKey=nextKeysPending[nextKey][i];childMapping[nextKeysPending[nextKey][i]]=getValueForKey(pendingNextKey);}}childMapping[nextKey]=getValueForKey(nextKey);}// Finally, add the keys which didn't appear before any key in `next`\nfor(i=0;i<pendingKeys.length;i++){childMapping[pendingKeys[i]]=getValueForKey(pendingKeys[i]);}return childMapping;}function getProp(child,prop,props){return props[prop]!=null?props[prop]:child.props[prop];}export function getInitialChildMapping(props,onExited){return getChildMapping(props.children,function(child){return/*#__PURE__*/cloneElement(child,{onExited:onExited.bind(null,child),in:true,appear:getProp(child,'appear',props),enter:getProp(child,'enter',props),exit:getProp(child,'exit',props)});});}export function getNextChildMapping(nextProps,prevChildMapping,onExited){var nextChildMapping=getChildMapping(nextProps.children);var children=mergeChildMappings(prevChildMapping,nextChildMapping);Object.keys(children).forEach(function(key){var child=children[key];if(!/*#__PURE__*/isValidElement(child))return;var hasPrev=(key in prevChildMapping);var hasNext=(key in nextChildMapping);var prevChild=prevChildMapping[key];var isLeaving=/*#__PURE__*/isValidElement(prevChild)&&!prevChild.props.in;// item is new (entering)\nif(hasNext&&(!hasPrev||isLeaving)){// console.log('entering', key)\nchildren[key]=/*#__PURE__*/cloneElement(child,{onExited:onExited.bind(null,child),in:true,exit:getProp(child,'exit',nextProps),enter:getProp(child,'enter',nextProps)});}else if(!hasNext&&hasPrev&&!isLeaving){// item is old (exiting)\n// console.log('leaving', key)\nchildren[key]=/*#__PURE__*/cloneElement(child,{in:false});}else if(hasNext&&hasPrev&&/*#__PURE__*/isValidElement(prevChild)){// item hasn't changed transition states\n// copy over the last transition props;\n// console.log('unchanged', key)\nchildren[key]=/*#__PURE__*/cloneElement(child,{onExited:onExited.bind(null,child),in:prevChild.props.in,exit:getProp(child,'exit',nextProps),enter:getProp(child,'enter',nextProps)});}});return children;}","map":{"version":3,"names":["Children","cloneElement","isValidElement","getChildMapping","children","mapFn","mapper","child","result","Object","create","map","c","forEach","key","mergeChildMappings","prev","next","getValueForKey","nextKeysPending","pendingKeys","prevKey","length","push","i","childMapping","nextKey","pendingNextKey","getProp","prop","props","getInitialChildMapping","onExited","bind","in","appear","enter","exit","getNextChildMapping","nextProps","prevChildMapping","nextChildMapping","keys","hasPrev","hasNext","prevChild","isLeaving"],"sources":["/home/nevin/Project-2/test-react-auth/frontend/src/node_modules/react-transition-group/esm/utils/ChildMapping.js"],"sourcesContent":["import { Children, cloneElement, isValidElement } from 'react';\n/**\n * Given `this.props.children`, return an object mapping key to child.\n *\n * @param {*} children `this.props.children`\n * @return {object} Mapping of key to child\n */\n\nexport function getChildMapping(children, mapFn) {\n  var mapper = function mapper(child) {\n    return mapFn && isValidElement(child) ? mapFn(child) : child;\n  };\n\n  var result = Object.create(null);\n  if (children) Children.map(children, function (c) {\n    return c;\n  }).forEach(function (child) {\n    // run the map function here instead so that the key is the computed one\n    result[child.key] = mapper(child);\n  });\n  return result;\n}\n/**\n * When you're adding or removing children some may be added or removed in the\n * same render pass. We want to show *both* since we want to simultaneously\n * animate elements in and out. This function takes a previous set of keys\n * and a new set of keys and merges them with its best guess of the correct\n * ordering. In the future we may expose some of the utilities in\n * ReactMultiChild to make this easy, but for now React itself does not\n * directly have this concept of the union of prevChildren and nextChildren\n * so we implement it here.\n *\n * @param {object} prev prev children as returned from\n * `ReactTransitionChildMapping.getChildMapping()`.\n * @param {object} next next children as returned from\n * `ReactTransitionChildMapping.getChildMapping()`.\n * @return {object} a key set that contains all keys in `prev` and all keys\n * in `next` in a reasonable order.\n */\n\nexport function mergeChildMappings(prev, next) {\n  prev = prev || {};\n  next = next || {};\n\n  function getValueForKey(key) {\n    return key in next ? next[key] : prev[key];\n  } // For each key of `next`, the list of keys to insert before that key in\n  // the combined list\n\n\n  var nextKeysPending = Object.create(null);\n  var pendingKeys = [];\n\n  for (var prevKey in prev) {\n    if (prevKey in next) {\n      if (pendingKeys.length) {\n        nextKeysPending[prevKey] = pendingKeys;\n        pendingKeys = [];\n      }\n    } else {\n      pendingKeys.push(prevKey);\n    }\n  }\n\n  var i;\n  var childMapping = {};\n\n  for (var nextKey in next) {\n    if (nextKeysPending[nextKey]) {\n      for (i = 0; i < nextKeysPending[nextKey].length; i++) {\n        var pendingNextKey = nextKeysPending[nextKey][i];\n        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);\n      }\n    }\n\n    childMapping[nextKey] = getValueForKey(nextKey);\n  } // Finally, add the keys which didn't appear before any key in `next`\n\n\n  for (i = 0; i < pendingKeys.length; i++) {\n    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);\n  }\n\n  return childMapping;\n}\n\nfunction getProp(child, prop, props) {\n  return props[prop] != null ? props[prop] : child.props[prop];\n}\n\nexport function getInitialChildMapping(props, onExited) {\n  return getChildMapping(props.children, function (child) {\n    return cloneElement(child, {\n      onExited: onExited.bind(null, child),\n      in: true,\n      appear: getProp(child, 'appear', props),\n      enter: getProp(child, 'enter', props),\n      exit: getProp(child, 'exit', props)\n    });\n  });\n}\nexport function getNextChildMapping(nextProps, prevChildMapping, onExited) {\n  var nextChildMapping = getChildMapping(nextProps.children);\n  var children = mergeChildMappings(prevChildMapping, nextChildMapping);\n  Object.keys(children).forEach(function (key) {\n    var child = children[key];\n    if (!isValidElement(child)) return;\n    var hasPrev = (key in prevChildMapping);\n    var hasNext = (key in nextChildMapping);\n    var prevChild = prevChildMapping[key];\n    var isLeaving = isValidElement(prevChild) && !prevChild.props.in; // item is new (entering)\n\n    if (hasNext && (!hasPrev || isLeaving)) {\n      // console.log('entering', key)\n      children[key] = cloneElement(child, {\n        onExited: onExited.bind(null, child),\n        in: true,\n        exit: getProp(child, 'exit', nextProps),\n        enter: getProp(child, 'enter', nextProps)\n      });\n    } else if (!hasNext && hasPrev && !isLeaving) {\n      // item is old (exiting)\n      // console.log('leaving', key)\n      children[key] = cloneElement(child, {\n        in: false\n      });\n    } else if (hasNext && hasPrev && isValidElement(prevChild)) {\n      // item hasn't changed transition states\n      // copy over the last transition props;\n      // console.log('unchanged', key)\n      children[key] = cloneElement(child, {\n        onExited: onExited.bind(null, child),\n        in: prevChild.props.in,\n        exit: getProp(child, 'exit', nextProps),\n        enter: getProp(child, 'enter', nextProps)\n      });\n    }\n  });\n  return children;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}