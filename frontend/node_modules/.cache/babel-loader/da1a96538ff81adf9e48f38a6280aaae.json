{"ast":null,"code":"'use client';// based on https://github.com/WICG/focus-visible/blob/v4.1.5/src/focus-visible.js\nimport*as React from'react';import{Timeout}from'../useTimeout/useTimeout';let hadKeyboardEvent=true;let hadFocusVisibleRecently=false;const hadFocusVisibleRecentlyTimeout=new Timeout();const inputTypesWhitelist={text:true,search:true,url:true,tel:true,email:true,password:true,number:true,date:true,month:true,week:true,time:true,datetime:true,'datetime-local':true};/**\n * Computes whether the given element should automatically trigger the\n * `focus-visible` class being added, i.e. whether it should always match\n * `:focus-visible` when focused.\n * @param {Element} node\n * @returns {boolean}\n */function focusTriggersKeyboardModality(node){const{type,tagName}=node;if(tagName==='INPUT'&&inputTypesWhitelist[type]&&!node.readOnly){return true;}if(tagName==='TEXTAREA'&&!node.readOnly){return true;}if(node.isContentEditable){return true;}return false;}/**\n * Keep track of our keyboard modality state with `hadKeyboardEvent`.\n * If the most recent user interaction was via the keyboard;\n * and the key press did not include a meta, alt/option, or control key;\n * then the modality is keyboard. Otherwise, the modality is not keyboard.\n * @param {KeyboardEvent} event\n */function handleKeyDown(event){if(event.metaKey||event.altKey||event.ctrlKey){return;}hadKeyboardEvent=true;}/**\n * If at any point a user clicks with a pointing device, ensure that we change\n * the modality away from keyboard.\n * This avoids the situation where a user presses a key on an already focused\n * element, and then clicks on a different element, focusing it with a\n * pointing device, while we still think we're in keyboard modality.\n */function handlePointerDown(){hadKeyboardEvent=false;}function handleVisibilityChange(){if(this.visibilityState==='hidden'){// If the tab becomes active again, the browser will handle calling focus\n// on the element (Safari actually calls it twice).\n// If this tab change caused a blur on an element with focus-visible,\n// re-apply the class when the user switches back to the tab.\nif(hadFocusVisibleRecently){hadKeyboardEvent=true;}}}function prepare(doc){doc.addEventListener('keydown',handleKeyDown,true);doc.addEventListener('mousedown',handlePointerDown,true);doc.addEventListener('pointerdown',handlePointerDown,true);doc.addEventListener('touchstart',handlePointerDown,true);doc.addEventListener('visibilitychange',handleVisibilityChange,true);}export function teardown(doc){doc.removeEventListener('keydown',handleKeyDown,true);doc.removeEventListener('mousedown',handlePointerDown,true);doc.removeEventListener('pointerdown',handlePointerDown,true);doc.removeEventListener('touchstart',handlePointerDown,true);doc.removeEventListener('visibilitychange',handleVisibilityChange,true);}function isFocusVisible(event){const{target}=event;try{return target.matches(':focus-visible');}catch(error){// Browsers not implementing :focus-visible will throw a SyntaxError.\n// We use our own heuristic for those browsers.\n// Rethrow might be better if it's not the expected error but do we really\n// want to crash if focus-visible malfunctioned?\n}// No need for validFocusTarget check. The user does that by attaching it to\n// focusable events only.\nreturn hadKeyboardEvent||focusTriggersKeyboardModality(target);}export default function useIsFocusVisible(){const ref=React.useCallback(node=>{if(node!=null){prepare(node.ownerDocument);}},[]);const isFocusVisibleRef=React.useRef(false);/**\n   * Should be called if a blur event is fired\n   */function handleBlurVisible(){// checking against potential state variable does not suffice if we focus and blur synchronously.\n// React wouldn't have time to trigger a re-render so `focusVisible` would be stale.\n// Ideally we would adjust `isFocusVisible(event)` to look at `relatedTarget` for blur events.\n// This doesn't work in IE11 due to https://github.com/facebook/react/issues/3751\n// TODO: check again if React releases their internal changes to focus event handling (https://github.com/facebook/react/pull/19186).\nif(isFocusVisibleRef.current){// To detect a tab/window switch, we look for a blur event followed\n// rapidly by a visibility change.\n// If we don't see a visibility change within 100ms, it's probably a\n// regular focus change.\nhadFocusVisibleRecently=true;hadFocusVisibleRecentlyTimeout.start(100,()=>{hadFocusVisibleRecently=false;});isFocusVisibleRef.current=false;return true;}return false;}/**\n   * Should be called if a blur event is fired\n   */function handleFocusVisible(event){if(isFocusVisible(event)){isFocusVisibleRef.current=true;return true;}return false;}return{isFocusVisibleRef,onFocus:handleFocusVisible,onBlur:handleBlurVisible,ref};}","map":{"version":3,"names":["React","Timeout","hadKeyboardEvent","hadFocusVisibleRecently","hadFocusVisibleRecentlyTimeout","inputTypesWhitelist","text","search","url","tel","email","password","number","date","month","week","time","datetime","focusTriggersKeyboardModality","node","type","tagName","readOnly","isContentEditable","handleKeyDown","event","metaKey","altKey","ctrlKey","handlePointerDown","handleVisibilityChange","visibilityState","prepare","doc","addEventListener","teardown","removeEventListener","isFocusVisible","target","matches","error","useIsFocusVisible","ref","useCallback","ownerDocument","isFocusVisibleRef","useRef","handleBlurVisible","current","start","handleFocusVisible","onFocus","onBlur"],"sources":["/home/nevin/Project-2/test-react-auth/frontend/src/node_modules/@mui/utils/useIsFocusVisible/useIsFocusVisible.js"],"sourcesContent":["'use client';\n\n// based on https://github.com/WICG/focus-visible/blob/v4.1.5/src/focus-visible.js\nimport * as React from 'react';\nimport { Timeout } from '../useTimeout/useTimeout';\nlet hadKeyboardEvent = true;\nlet hadFocusVisibleRecently = false;\nconst hadFocusVisibleRecentlyTimeout = new Timeout();\nconst inputTypesWhitelist = {\n  text: true,\n  search: true,\n  url: true,\n  tel: true,\n  email: true,\n  password: true,\n  number: true,\n  date: true,\n  month: true,\n  week: true,\n  time: true,\n  datetime: true,\n  'datetime-local': true\n};\n\n/**\n * Computes whether the given element should automatically trigger the\n * `focus-visible` class being added, i.e. whether it should always match\n * `:focus-visible` when focused.\n * @param {Element} node\n * @returns {boolean}\n */\nfunction focusTriggersKeyboardModality(node) {\n  const {\n    type,\n    tagName\n  } = node;\n  if (tagName === 'INPUT' && inputTypesWhitelist[type] && !node.readOnly) {\n    return true;\n  }\n  if (tagName === 'TEXTAREA' && !node.readOnly) {\n    return true;\n  }\n  if (node.isContentEditable) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Keep track of our keyboard modality state with `hadKeyboardEvent`.\n * If the most recent user interaction was via the keyboard;\n * and the key press did not include a meta, alt/option, or control key;\n * then the modality is keyboard. Otherwise, the modality is not keyboard.\n * @param {KeyboardEvent} event\n */\nfunction handleKeyDown(event) {\n  if (event.metaKey || event.altKey || event.ctrlKey) {\n    return;\n  }\n  hadKeyboardEvent = true;\n}\n\n/**\n * If at any point a user clicks with a pointing device, ensure that we change\n * the modality away from keyboard.\n * This avoids the situation where a user presses a key on an already focused\n * element, and then clicks on a different element, focusing it with a\n * pointing device, while we still think we're in keyboard modality.\n */\nfunction handlePointerDown() {\n  hadKeyboardEvent = false;\n}\nfunction handleVisibilityChange() {\n  if (this.visibilityState === 'hidden') {\n    // If the tab becomes active again, the browser will handle calling focus\n    // on the element (Safari actually calls it twice).\n    // If this tab change caused a blur on an element with focus-visible,\n    // re-apply the class when the user switches back to the tab.\n    if (hadFocusVisibleRecently) {\n      hadKeyboardEvent = true;\n    }\n  }\n}\nfunction prepare(doc) {\n  doc.addEventListener('keydown', handleKeyDown, true);\n  doc.addEventListener('mousedown', handlePointerDown, true);\n  doc.addEventListener('pointerdown', handlePointerDown, true);\n  doc.addEventListener('touchstart', handlePointerDown, true);\n  doc.addEventListener('visibilitychange', handleVisibilityChange, true);\n}\nexport function teardown(doc) {\n  doc.removeEventListener('keydown', handleKeyDown, true);\n  doc.removeEventListener('mousedown', handlePointerDown, true);\n  doc.removeEventListener('pointerdown', handlePointerDown, true);\n  doc.removeEventListener('touchstart', handlePointerDown, true);\n  doc.removeEventListener('visibilitychange', handleVisibilityChange, true);\n}\nfunction isFocusVisible(event) {\n  const {\n    target\n  } = event;\n  try {\n    return target.matches(':focus-visible');\n  } catch (error) {\n    // Browsers not implementing :focus-visible will throw a SyntaxError.\n    // We use our own heuristic for those browsers.\n    // Rethrow might be better if it's not the expected error but do we really\n    // want to crash if focus-visible malfunctioned?\n  }\n\n  // No need for validFocusTarget check. The user does that by attaching it to\n  // focusable events only.\n  return hadKeyboardEvent || focusTriggersKeyboardModality(target);\n}\nexport default function useIsFocusVisible() {\n  const ref = React.useCallback(node => {\n    if (node != null) {\n      prepare(node.ownerDocument);\n    }\n  }, []);\n  const isFocusVisibleRef = React.useRef(false);\n\n  /**\n   * Should be called if a blur event is fired\n   */\n  function handleBlurVisible() {\n    // checking against potential state variable does not suffice if we focus and blur synchronously.\n    // React wouldn't have time to trigger a re-render so `focusVisible` would be stale.\n    // Ideally we would adjust `isFocusVisible(event)` to look at `relatedTarget` for blur events.\n    // This doesn't work in IE11 due to https://github.com/facebook/react/issues/3751\n    // TODO: check again if React releases their internal changes to focus event handling (https://github.com/facebook/react/pull/19186).\n    if (isFocusVisibleRef.current) {\n      // To detect a tab/window switch, we look for a blur event followed\n      // rapidly by a visibility change.\n      // If we don't see a visibility change within 100ms, it's probably a\n      // regular focus change.\n      hadFocusVisibleRecently = true;\n      hadFocusVisibleRecentlyTimeout.start(100, () => {\n        hadFocusVisibleRecently = false;\n      });\n      isFocusVisibleRef.current = false;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Should be called if a blur event is fired\n   */\n  function handleFocusVisible(event) {\n    if (isFocusVisible(event)) {\n      isFocusVisibleRef.current = true;\n      return true;\n    }\n    return false;\n  }\n  return {\n    isFocusVisibleRef,\n    onFocus: handleFocusVisible,\n    onBlur: handleBlurVisible,\n    ref\n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}