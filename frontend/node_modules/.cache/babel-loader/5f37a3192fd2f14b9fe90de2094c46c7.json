{"ast":null,"code":"import _extends from\"@babel/runtime/helpers/esm/extends\";import{ListActionTypes}from'./listActions.types';/**\n * Looks up the next valid item to highlight within the list.\n *\n * @param currentIndex The index of the start of the search.\n * @param lookupDirection Whether to look for the next or previous item.\n * @param items The array of items to search.\n * @param includeDisabledItems Whether to include disabled items in the search.\n * @param isItemDisabled A function that determines whether an item is disabled.\n * @param wrapAround Whether to wrap around the list when searching.\n * @returns The index of the next valid item to highlight or -1 if no valid item is found.\n */function findValidItemToHighlight(currentIndex,lookupDirection,items,includeDisabledItems,isItemDisabled,wrapAround){if(items.length===0||!includeDisabledItems&&items.every((item,itemIndex)=>isItemDisabled(item,itemIndex))){return-1;}let nextFocus=currentIndex;for(;;){// No valid items found\nif(!wrapAround&&lookupDirection==='next'&&nextFocus===items.length||!wrapAround&&lookupDirection==='previous'&&nextFocus===-1){return-1;}const nextFocusDisabled=includeDisabledItems?false:isItemDisabled(items[nextFocus],nextFocus);if(nextFocusDisabled){nextFocus+=lookupDirection==='next'?1:-1;if(wrapAround){nextFocus=(nextFocus+items.length)%items.length;}}else{return nextFocus;}}}/**\n * Gets the next item to highlight based on the current highlighted item and the search direction.\n *\n * @param previouslyHighlightedValue The item from which to start the search for the next candidate.\n * @param offset The offset from the previously highlighted item to search for the next candidate or a special named value ('reset', 'start', 'end').\n * @param context The list action context.\n *\n * @returns The next item to highlight or null if no item is valid.\n */export function moveHighlight(previouslyHighlightedValue,offset,context){var _items$nextIndex;const{items,isItemDisabled,disableListWrap,disabledItemsFocusable,itemComparer,focusManagement}=context;// TODO: make this configurable\n// The always should be an item highlighted when focus is managed by the DOM\n// so that it's accessible by the `tab` key.\nconst defaultHighlightedIndex=focusManagement==='DOM'?0:-1;const maxIndex=items.length-1;const previouslyHighlightedIndex=previouslyHighlightedValue==null?-1:items.findIndex(item=>itemComparer(item,previouslyHighlightedValue));let nextIndexCandidate;let lookupDirection;let wrapAround=!disableListWrap;switch(offset){case'reset':if(defaultHighlightedIndex===-1){return null;}nextIndexCandidate=0;lookupDirection='next';wrapAround=false;break;case'start':nextIndexCandidate=0;lookupDirection='next';wrapAround=false;break;case'end':nextIndexCandidate=maxIndex;lookupDirection='previous';wrapAround=false;break;default:{const newIndex=previouslyHighlightedIndex+offset;if(newIndex<0){if(!wrapAround&&previouslyHighlightedIndex!==-1||Math.abs(offset)>1){nextIndexCandidate=0;lookupDirection='next';}else{nextIndexCandidate=maxIndex;lookupDirection='previous';}}else if(newIndex>maxIndex){if(!wrapAround||Math.abs(offset)>1){nextIndexCandidate=maxIndex;lookupDirection='previous';}else{nextIndexCandidate=0;lookupDirection='next';}}else{nextIndexCandidate=newIndex;lookupDirection=offset>=0?'next':'previous';}}}const nextIndex=findValidItemToHighlight(nextIndexCandidate,lookupDirection,items,disabledItemsFocusable,isItemDisabled,wrapAround);// If there are no valid items to highlight, return the previously highlighted item (if it's still valid).\nif(nextIndex===-1&&previouslyHighlightedValue!==null&&!isItemDisabled(previouslyHighlightedValue,previouslyHighlightedIndex)){return previouslyHighlightedValue;}return(_items$nextIndex=items[nextIndex])!=null?_items$nextIndex:null;}/**\n * Toggles the selection of an item.\n *\n * @param item Item to toggle.\n * @param selectedValues Already selected items.\n * @param selectionMode The number of items that can be simultanously selected.\n * @param itemComparer A custom item comparer function.\n *\n * @returns The new array of selected items.\n */export function toggleSelection(item,selectedValues,selectionMode,itemComparer){if(selectionMode==='none'){return[];}if(selectionMode==='single'){// if the item to select has already been selected, return the original array\nif(itemComparer(selectedValues[0],item)){return selectedValues;}return[item];}// The toggled item is selected; remove it from the selection.\nif(selectedValues.some(sv=>itemComparer(sv,item))){return selectedValues.filter(sv=>!itemComparer(sv,item));}// The toggled item is not selected - add it to the selection.\nreturn[...selectedValues,item];}/**\n * Handles item selection in a list.\n *\n * @param item - The item to be selected.\n * @param state - The current state of the list.\n * @param context - The context of the list action.\n * @returns The new state of the list after the item has been selected, or the original state if the item is disabled.\n */export function handleItemSelection(item,state,context){const{itemComparer,isItemDisabled,selectionMode,items}=context;const{selectedValues}=state;const itemIndex=items.findIndex(i=>itemComparer(item,i));if(isItemDisabled(item,itemIndex)){return state;}// if the item is already selected, remove it from the selection, otherwise add it\nconst newSelectedValues=toggleSelection(item,selectedValues,selectionMode,itemComparer);return _extends({},state,{selectedValues:newSelectedValues,highlightedValue:item});}function handleKeyDown(key,state,context){const previouslySelectedValue=state.highlightedValue;const{orientation,pageSize}=context;switch(key){case'Home':return _extends({},state,{highlightedValue:moveHighlight(previouslySelectedValue,'start',context)});case'End':return _extends({},state,{highlightedValue:moveHighlight(previouslySelectedValue,'end',context)});case'PageUp':return _extends({},state,{highlightedValue:moveHighlight(previouslySelectedValue,-pageSize,context)});case'PageDown':return _extends({},state,{highlightedValue:moveHighlight(previouslySelectedValue,pageSize,context)});case'ArrowUp':if(orientation!=='vertical'){break;}return _extends({},state,{highlightedValue:moveHighlight(previouslySelectedValue,-1,context)});case'ArrowDown':if(orientation!=='vertical'){break;}return _extends({},state,{highlightedValue:moveHighlight(previouslySelectedValue,1,context)});case'ArrowLeft':{if(orientation==='vertical'){break;}const offset=orientation==='horizontal-ltr'?-1:1;return _extends({},state,{highlightedValue:moveHighlight(previouslySelectedValue,offset,context)});}case'ArrowRight':{if(orientation==='vertical'){break;}const offset=orientation==='horizontal-ltr'?1:-1;return _extends({},state,{highlightedValue:moveHighlight(previouslySelectedValue,offset,context)});}case'Enter':case' ':if(state.highlightedValue===null){return state;}return handleItemSelection(state.highlightedValue,state,context);default:break;}return state;}function handleBlur(state,context){if(context.focusManagement==='DOM'){return state;}return _extends({},state,{highlightedValue:null});}function textCriteriaMatches(nextFocus,searchString,stringifyItem){var _stringifyItem;const text=(_stringifyItem=stringifyItem(nextFocus))==null?void 0:_stringifyItem.trim().toLowerCase();if(!text||text.length===0){// Make item not navigable if stringification fails or results in empty string.\nreturn false;}return text.indexOf(searchString)===0;}function handleTextNavigation(state,searchString,context){const{items,isItemDisabled,disabledItemsFocusable,getItemAsString}=context;const startWithCurrentItem=searchString.length>1;let nextItem=startWithCurrentItem?state.highlightedValue:moveHighlight(state.highlightedValue,1,context);for(let index=0;index<items.length;index+=1){// Return un-mutated state if looped back to the currently highlighted value\nif(!nextItem||!startWithCurrentItem&&state.highlightedValue===nextItem){return state;}if(textCriteriaMatches(nextItem,searchString,getItemAsString)&&(!isItemDisabled(nextItem,items.indexOf(nextItem))||disabledItemsFocusable)){// The nextItem is the element to be highlighted\nreturn _extends({},state,{highlightedValue:nextItem});}// Move to the next element.\nnextItem=moveHighlight(nextItem,1,context);}// No item matches the text search criteria\nreturn state;}function handleItemsChange(items,previousItems,state,context){var _state$selectedValues;const{itemComparer,focusManagement}=context;let newHighlightedValue=null;if(state.highlightedValue!=null){var _items$find;newHighlightedValue=(_items$find=items.find(item=>itemComparer(item,state.highlightedValue)))!=null?_items$find:null;}else if(focusManagement==='DOM'&&previousItems.length===0){newHighlightedValue=moveHighlight(null,'reset',context);}// exclude selected values that are no longer in the items list\nconst selectedValues=(_state$selectedValues=state.selectedValues)!=null?_state$selectedValues:[];const newSelectedValues=selectedValues.filter(selectedValue=>items.some(item=>itemComparer(item,selectedValue)));return _extends({},state,{highlightedValue:newHighlightedValue,selectedValues:newSelectedValues});}function handleResetHighlight(state,context){return _extends({},state,{highlightedValue:moveHighlight(null,'reset',context)});}function handleHighlightLast(state,context){return _extends({},state,{highlightedValue:moveHighlight(null,'end',context)});}function handleClearSelection(state,context){return _extends({},state,{selectedValues:[],highlightedValue:moveHighlight(null,'reset',context)});}export function listReducer(state,action){const{type,context}=action;switch(type){case ListActionTypes.keyDown:return handleKeyDown(action.key,state,context);case ListActionTypes.itemClick:return handleItemSelection(action.item,state,context);case ListActionTypes.blur:return handleBlur(state,context);case ListActionTypes.textNavigation:return handleTextNavigation(state,action.searchString,context);case ListActionTypes.itemsChange:return handleItemsChange(action.items,action.previousItems,state,context);case ListActionTypes.resetHighlight:return handleResetHighlight(state,context);case ListActionTypes.highlightLast:return handleHighlightLast(state,context);case ListActionTypes.clearSelection:return handleClearSelection(state,context);default:return state;}}","map":{"version":3,"names":["_extends","ListActionTypes","findValidItemToHighlight","currentIndex","lookupDirection","items","includeDisabledItems","isItemDisabled","wrapAround","length","every","item","itemIndex","nextFocus","nextFocusDisabled","moveHighlight","previouslyHighlightedValue","offset","context","_items$nextIndex","disableListWrap","disabledItemsFocusable","itemComparer","focusManagement","defaultHighlightedIndex","maxIndex","previouslyHighlightedIndex","findIndex","nextIndexCandidate","newIndex","Math","abs","nextIndex","toggleSelection","selectedValues","selectionMode","some","sv","filter","handleItemSelection","state","i","newSelectedValues","highlightedValue","handleKeyDown","key","previouslySelectedValue","orientation","pageSize","handleBlur","textCriteriaMatches","searchString","stringifyItem","_stringifyItem","text","trim","toLowerCase","indexOf","handleTextNavigation","getItemAsString","startWithCurrentItem","nextItem","index","handleItemsChange","previousItems","_state$selectedValues","newHighlightedValue","_items$find","find","selectedValue","handleResetHighlight","handleHighlightLast","handleClearSelection","listReducer","action","type","keyDown","itemClick","blur","textNavigation","itemsChange","resetHighlight","highlightLast","clearSelection"],"sources":["/home/nevin/Project-2/test-react-auth/frontend/src/node_modules/@mui/base/useList/listReducer.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { ListActionTypes } from './listActions.types';\n/**\n * Looks up the next valid item to highlight within the list.\n *\n * @param currentIndex The index of the start of the search.\n * @param lookupDirection Whether to look for the next or previous item.\n * @param items The array of items to search.\n * @param includeDisabledItems Whether to include disabled items in the search.\n * @param isItemDisabled A function that determines whether an item is disabled.\n * @param wrapAround Whether to wrap around the list when searching.\n * @returns The index of the next valid item to highlight or -1 if no valid item is found.\n */\nfunction findValidItemToHighlight(currentIndex, lookupDirection, items, includeDisabledItems, isItemDisabled, wrapAround) {\n  if (items.length === 0 || !includeDisabledItems && items.every((item, itemIndex) => isItemDisabled(item, itemIndex))) {\n    return -1;\n  }\n  let nextFocus = currentIndex;\n  for (;;) {\n    // No valid items found\n    if (!wrapAround && lookupDirection === 'next' && nextFocus === items.length || !wrapAround && lookupDirection === 'previous' && nextFocus === -1) {\n      return -1;\n    }\n    const nextFocusDisabled = includeDisabledItems ? false : isItemDisabled(items[nextFocus], nextFocus);\n    if (nextFocusDisabled) {\n      nextFocus += lookupDirection === 'next' ? 1 : -1;\n      if (wrapAround) {\n        nextFocus = (nextFocus + items.length) % items.length;\n      }\n    } else {\n      return nextFocus;\n    }\n  }\n}\n\n/**\n * Gets the next item to highlight based on the current highlighted item and the search direction.\n *\n * @param previouslyHighlightedValue The item from which to start the search for the next candidate.\n * @param offset The offset from the previously highlighted item to search for the next candidate or a special named value ('reset', 'start', 'end').\n * @param context The list action context.\n *\n * @returns The next item to highlight or null if no item is valid.\n */\nexport function moveHighlight(previouslyHighlightedValue, offset, context) {\n  var _items$nextIndex;\n  const {\n    items,\n    isItemDisabled,\n    disableListWrap,\n    disabledItemsFocusable,\n    itemComparer,\n    focusManagement\n  } = context;\n\n  // TODO: make this configurable\n  // The always should be an item highlighted when focus is managed by the DOM\n  // so that it's accessible by the `tab` key.\n  const defaultHighlightedIndex = focusManagement === 'DOM' ? 0 : -1;\n  const maxIndex = items.length - 1;\n  const previouslyHighlightedIndex = previouslyHighlightedValue == null ? -1 : items.findIndex(item => itemComparer(item, previouslyHighlightedValue));\n  let nextIndexCandidate;\n  let lookupDirection;\n  let wrapAround = !disableListWrap;\n  switch (offset) {\n    case 'reset':\n      if (defaultHighlightedIndex === -1) {\n        return null;\n      }\n      nextIndexCandidate = 0;\n      lookupDirection = 'next';\n      wrapAround = false;\n      break;\n    case 'start':\n      nextIndexCandidate = 0;\n      lookupDirection = 'next';\n      wrapAround = false;\n      break;\n    case 'end':\n      nextIndexCandidate = maxIndex;\n      lookupDirection = 'previous';\n      wrapAround = false;\n      break;\n    default:\n      {\n        const newIndex = previouslyHighlightedIndex + offset;\n        if (newIndex < 0) {\n          if (!wrapAround && previouslyHighlightedIndex !== -1 || Math.abs(offset) > 1) {\n            nextIndexCandidate = 0;\n            lookupDirection = 'next';\n          } else {\n            nextIndexCandidate = maxIndex;\n            lookupDirection = 'previous';\n          }\n        } else if (newIndex > maxIndex) {\n          if (!wrapAround || Math.abs(offset) > 1) {\n            nextIndexCandidate = maxIndex;\n            lookupDirection = 'previous';\n          } else {\n            nextIndexCandidate = 0;\n            lookupDirection = 'next';\n          }\n        } else {\n          nextIndexCandidate = newIndex;\n          lookupDirection = offset >= 0 ? 'next' : 'previous';\n        }\n      }\n  }\n  const nextIndex = findValidItemToHighlight(nextIndexCandidate, lookupDirection, items, disabledItemsFocusable, isItemDisabled, wrapAround);\n\n  // If there are no valid items to highlight, return the previously highlighted item (if it's still valid).\n  if (nextIndex === -1 && previouslyHighlightedValue !== null && !isItemDisabled(previouslyHighlightedValue, previouslyHighlightedIndex)) {\n    return previouslyHighlightedValue;\n  }\n  return (_items$nextIndex = items[nextIndex]) != null ? _items$nextIndex : null;\n}\n\n/**\n * Toggles the selection of an item.\n *\n * @param item Item to toggle.\n * @param selectedValues Already selected items.\n * @param selectionMode The number of items that can be simultanously selected.\n * @param itemComparer A custom item comparer function.\n *\n * @returns The new array of selected items.\n */\nexport function toggleSelection(item, selectedValues, selectionMode, itemComparer) {\n  if (selectionMode === 'none') {\n    return [];\n  }\n  if (selectionMode === 'single') {\n    // if the item to select has already been selected, return the original array\n    if (itemComparer(selectedValues[0], item)) {\n      return selectedValues;\n    }\n    return [item];\n  }\n\n  // The toggled item is selected; remove it from the selection.\n  if (selectedValues.some(sv => itemComparer(sv, item))) {\n    return selectedValues.filter(sv => !itemComparer(sv, item));\n  }\n\n  // The toggled item is not selected - add it to the selection.\n  return [...selectedValues, item];\n}\n\n/**\n * Handles item selection in a list.\n *\n * @param item - The item to be selected.\n * @param state - The current state of the list.\n * @param context - The context of the list action.\n * @returns The new state of the list after the item has been selected, or the original state if the item is disabled.\n */\nexport function handleItemSelection(item, state, context) {\n  const {\n    itemComparer,\n    isItemDisabled,\n    selectionMode,\n    items\n  } = context;\n  const {\n    selectedValues\n  } = state;\n  const itemIndex = items.findIndex(i => itemComparer(item, i));\n  if (isItemDisabled(item, itemIndex)) {\n    return state;\n  }\n\n  // if the item is already selected, remove it from the selection, otherwise add it\n  const newSelectedValues = toggleSelection(item, selectedValues, selectionMode, itemComparer);\n  return _extends({}, state, {\n    selectedValues: newSelectedValues,\n    highlightedValue: item\n  });\n}\nfunction handleKeyDown(key, state, context) {\n  const previouslySelectedValue = state.highlightedValue;\n  const {\n    orientation,\n    pageSize\n  } = context;\n  switch (key) {\n    case 'Home':\n      return _extends({}, state, {\n        highlightedValue: moveHighlight(previouslySelectedValue, 'start', context)\n      });\n    case 'End':\n      return _extends({}, state, {\n        highlightedValue: moveHighlight(previouslySelectedValue, 'end', context)\n      });\n    case 'PageUp':\n      return _extends({}, state, {\n        highlightedValue: moveHighlight(previouslySelectedValue, -pageSize, context)\n      });\n    case 'PageDown':\n      return _extends({}, state, {\n        highlightedValue: moveHighlight(previouslySelectedValue, pageSize, context)\n      });\n    case 'ArrowUp':\n      if (orientation !== 'vertical') {\n        break;\n      }\n      return _extends({}, state, {\n        highlightedValue: moveHighlight(previouslySelectedValue, -1, context)\n      });\n    case 'ArrowDown':\n      if (orientation !== 'vertical') {\n        break;\n      }\n      return _extends({}, state, {\n        highlightedValue: moveHighlight(previouslySelectedValue, 1, context)\n      });\n    case 'ArrowLeft':\n      {\n        if (orientation === 'vertical') {\n          break;\n        }\n        const offset = orientation === 'horizontal-ltr' ? -1 : 1;\n        return _extends({}, state, {\n          highlightedValue: moveHighlight(previouslySelectedValue, offset, context)\n        });\n      }\n    case 'ArrowRight':\n      {\n        if (orientation === 'vertical') {\n          break;\n        }\n        const offset = orientation === 'horizontal-ltr' ? 1 : -1;\n        return _extends({}, state, {\n          highlightedValue: moveHighlight(previouslySelectedValue, offset, context)\n        });\n      }\n    case 'Enter':\n    case ' ':\n      if (state.highlightedValue === null) {\n        return state;\n      }\n      return handleItemSelection(state.highlightedValue, state, context);\n    default:\n      break;\n  }\n  return state;\n}\nfunction handleBlur(state, context) {\n  if (context.focusManagement === 'DOM') {\n    return state;\n  }\n  return _extends({}, state, {\n    highlightedValue: null\n  });\n}\nfunction textCriteriaMatches(nextFocus, searchString, stringifyItem) {\n  var _stringifyItem;\n  const text = (_stringifyItem = stringifyItem(nextFocus)) == null ? void 0 : _stringifyItem.trim().toLowerCase();\n  if (!text || text.length === 0) {\n    // Make item not navigable if stringification fails or results in empty string.\n    return false;\n  }\n  return text.indexOf(searchString) === 0;\n}\nfunction handleTextNavigation(state, searchString, context) {\n  const {\n    items,\n    isItemDisabled,\n    disabledItemsFocusable,\n    getItemAsString\n  } = context;\n  const startWithCurrentItem = searchString.length > 1;\n  let nextItem = startWithCurrentItem ? state.highlightedValue : moveHighlight(state.highlightedValue, 1, context);\n  for (let index = 0; index < items.length; index += 1) {\n    // Return un-mutated state if looped back to the currently highlighted value\n    if (!nextItem || !startWithCurrentItem && state.highlightedValue === nextItem) {\n      return state;\n    }\n    if (textCriteriaMatches(nextItem, searchString, getItemAsString) && (!isItemDisabled(nextItem, items.indexOf(nextItem)) || disabledItemsFocusable)) {\n      // The nextItem is the element to be highlighted\n      return _extends({}, state, {\n        highlightedValue: nextItem\n      });\n    }\n    // Move to the next element.\n    nextItem = moveHighlight(nextItem, 1, context);\n  }\n\n  // No item matches the text search criteria\n  return state;\n}\nfunction handleItemsChange(items, previousItems, state, context) {\n  var _state$selectedValues;\n  const {\n    itemComparer,\n    focusManagement\n  } = context;\n  let newHighlightedValue = null;\n  if (state.highlightedValue != null) {\n    var _items$find;\n    newHighlightedValue = (_items$find = items.find(item => itemComparer(item, state.highlightedValue))) != null ? _items$find : null;\n  } else if (focusManagement === 'DOM' && previousItems.length === 0) {\n    newHighlightedValue = moveHighlight(null, 'reset', context);\n  }\n\n  // exclude selected values that are no longer in the items list\n  const selectedValues = (_state$selectedValues = state.selectedValues) != null ? _state$selectedValues : [];\n  const newSelectedValues = selectedValues.filter(selectedValue => items.some(item => itemComparer(item, selectedValue)));\n  return _extends({}, state, {\n    highlightedValue: newHighlightedValue,\n    selectedValues: newSelectedValues\n  });\n}\nfunction handleResetHighlight(state, context) {\n  return _extends({}, state, {\n    highlightedValue: moveHighlight(null, 'reset', context)\n  });\n}\nfunction handleHighlightLast(state, context) {\n  return _extends({}, state, {\n    highlightedValue: moveHighlight(null, 'end', context)\n  });\n}\nfunction handleClearSelection(state, context) {\n  return _extends({}, state, {\n    selectedValues: [],\n    highlightedValue: moveHighlight(null, 'reset', context)\n  });\n}\nexport function listReducer(state, action) {\n  const {\n    type,\n    context\n  } = action;\n  switch (type) {\n    case ListActionTypes.keyDown:\n      return handleKeyDown(action.key, state, context);\n    case ListActionTypes.itemClick:\n      return handleItemSelection(action.item, state, context);\n    case ListActionTypes.blur:\n      return handleBlur(state, context);\n    case ListActionTypes.textNavigation:\n      return handleTextNavigation(state, action.searchString, context);\n    case ListActionTypes.itemsChange:\n      return handleItemsChange(action.items, action.previousItems, state, context);\n    case ListActionTypes.resetHighlight:\n      return handleResetHighlight(state, context);\n    case ListActionTypes.highlightLast:\n      return handleHighlightLast(state, context);\n    case ListActionTypes.clearSelection:\n      return handleClearSelection(state, context);\n    default:\n      return state;\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}